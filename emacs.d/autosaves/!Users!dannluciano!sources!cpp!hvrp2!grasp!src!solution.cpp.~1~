#include "solution.hpp"
#include <cmath>

using namespace std;

Solution::Solution()
{
    this->vehicles = new vector<Vehicle>();
    this->cost = 0.0;
}

Solution::Solution(const Solution& solution)
{
    this->vehicles = new vector<Vehicle>();
    for (size_t i = 0; i < solution.GetVehicles().size(); ++i) {
        this->vehicles->push_back(solution.GetVehicles().at(i));
    }
    this->CalculateCost();
}

Solution& Solution::operator=(const Solution& solution) {
    if (this != &solution) {
        this->cost = solution.GetCost();
        delete this->vehicles;
        this->vehicles = new vector<Vehicle>();
        for (size_t i = 0; i < solution.GetVehicles().size(); ++i)
        {
            this->vehicles->push_back(solution.GetVehicles().at(i));
        }
    }
    return *this;
}

Solution::~Solution()
{
  delete this->vehicles;
}


bool Solution::AddVehicle(const Vehicle& vehicle) {
    if (this->vehicles != NULL) {
        this->vehicles->push_back(vehicle);
        return true;
    }
    return false;
}

void Solution::CalculateCost()
{
  if (this->IsFeasible())
    {
      double cost = 0.0;
      size_t i;
      for (i = 0; i < this->vehicles->size(); ++i)
        {
          Vehicle& vehicle = this->vehicles->at(i);
          cost += vehicle.GetVehicleType().GetCost();
          vehicle.GetBetterRouter();
          size_t j;
          for (j = 0; j < vehicle.GetCustomers().size()-1; ++j)
            {
              cost += euclidian_distance(vehicle.GetCustomers().at(j).GetX(),
                                         vehicle.GetCustomers().at(j).GetY(),
                                         vehicle.GetCustomers().at(j+1).GetX(),
                                         vehicle.GetCustomers().at(j+1).GetY()
                                         );
            }
        }
      this->cost = cost;
    }
  else
    {
      this->cost = INFINITY;
    }
}

bool Solution::IsFeasible() const {
    double sum_all_demand = 0.0;
    size_t i;
    for (i = 0; i < this->vehicles->size(); ++i) {
        Vehicle vehicle = this->vehicles->at(i);
        double sum_demand = 0.0;
        size_t j;
        for (j = 0; j < vehicle.GetCustomers().size(); ++j) {
            Customer customer = vehicle.GetCustomers().at(j);
            sum_demand += customer.GetDemand();
            sum_all_demand += customer.GetDemand();
        }
        if (sum_demand > vehicle.GetVehicleType().GetVolume()) {
          return false;
        }
    }
    if (sum_all_demand != Configuration::sum_all_demand) {
        return false;
    }
    return true;
}

ostream& operator<<(ostream& os, Solution& solution) {
    os << "Cost: " << solution.cost << endl;
    os << "Steps: " << endl;
    for (size_t i = 0; i < solution.vehicles->size(); ++i)
    {
        os << "\t" << solution.vehicles->at(i).GetVehicleType().GetType() << ":";
        for (size_t j = 0; j < solution.vehicles->at(i).GetCustomers().size(); ++j)
        {
            os << "-" << solution.vehicles->at(i).GetCustomers().at(j).GetLabel();
        }
        os << endl;
    }
    return os;
}

vector<Vehicle>& Solution::GetVehicles() const {
    return *(this->vehicles);
}

double Solution::GetCost() const {
    return this->cost;
}

Solution& Solution::GenerateContructionSolution() {
    Solution* solution = new Solution();
    vector<Customer> customers_not_solved = vector<Customer>();
    int i;
    for (i = 1; i <= Configuration::number_of_customers; ++i) {
        customers_not_solved.push_back(Configuration::customers.at(i));
    }
    while (customers_not_solved.size() != 0) {
        Vehicle* vehicle = NULL;
        int vehicle_type_id = rand() % Configuration::number_of_types_of_vehicles;
        vehicle = new Vehicle(Configuration::vehicle_types.at(vehicle_type_id));
        vehicle->AddCustomer(Configuration::customers.at(0));
        while (true) {
            if (customers_not_solved.size() == 0) {
                vehicle->AddCustomer(Configuration::customers.at(0));
                break;
            }
            else {
                int customer_id = rand() % customers_not_solved.size();
                if (vehicle->AddCustomer(customers_not_solved.at(customer_id))) {
                    customers_not_solved.erase(customers_not_solved.begin()+customer_id);
                }
                else {
                    vehicle->AddCustomer(Configuration::customers.at(0));
                    break;
                }
            }
            
        }
        if (vehicle->GetCustomers().size() > 2 ) {
            solution->AddVehicle(*vehicle);
            delete vehicle;
        } else {
            delete vehicle;
        }
        
    }
    solution->CalculateCost();
    return *solution;
}

Solution& Solution::GenerateNeighborhood() {
    int opt = rand()%3;
    switch(opt){
    case 1:
        return this->OneOneExchange();
        break;
    case 2:
        return this->OneZeroExchange();
        break;
    case 3:
        return this->TwoOpt();
        break;
    default:
        return this->OneOneExchange();
        break;
    }
}

Solution& Solution::OneOneExchange() {
    int index_vehicle1 = rand() % this->vehicles->size();
    int index_vehicle2 = rand() % this->vehicles->size();
    int index_customer1 = rand() % this->vehicles->at(index_vehicle1).GetCustomers().size();
    int index_customer2 = rand() % this->vehicles->at(index_vehicle2).GetCustomers().size();

    Customer aux = this->vehicles->at(index_vehicle1).GetCustomers().at(index_customer1);
    this->vehicles->at(index_vehicle1).GetCustomers().at(index_customer1) = this->vehicles->at(index_vehicle2).GetCustomers().at(index_customer2);
    this->vehicles->at(index_vehicle2).GetCustomers().at(index_customer2) = aux;
    return *this;
}

// FIXME Bug
Solution& Solution::OneZeroExchange() {
    cout << *this << endl;
    while(true)
    {
        int vehicle1_index = rand() % this->vehicles->size();
        int vehicle2_index = rand() % this->vehicles->size();
        int customer2_index = abs((long int)((rand() % this->vehicles->at(vehicle2_index).GetCustomers().size() -3) +1));
        cout << vehicle1_index << ":" << vehicle2_index << ":" << customer2_index << endl;

        Customer customer2 = this->vehicles->at(vehicle2_index).GetCustomers().at(customer2_index);

        if (this->vehicles->at(vehicle1_index).AddCustomer(customer2) && this->vehicles->at(vehicle2_index).RemoveCustomer(customer2_index))
        {
            cout << *this << endl;
            getchar();
            return *this;
        }
    };
}

Solution& Solution::TwoOpt() {
    return *this;
}

void Solution::MakeRouteFile() {
    ofstream routes_file("routes.txt", fstream::trunc);
    if (routes_file.good()) {
        for (size_t i = 0; i < this->GetVehicles().size(); ++i) {
            Vehicle& vehicle = this->GetVehicles().at(i);
            for (size_t j = 0; j < vehicle.GetCustomers().size(); ++j) {
                Customer& customer = vehicle.GetCustomers().at(j);
                routes_file << vehicle.GetVehicleType().GetType() << "\t";
                routes_file << customer.GetX() << "\t";
                routes_file << customer.GetY() << endl;
            }
        }
    }
}
